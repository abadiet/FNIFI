@startuml

package fnifi {
    class FNIFI {
        -_colls : std::vector<Collection*>
        -_sortingAlgo : sxeval::SXEval<expr_t>
        -_filteringAlgo : sxeval::SXEval<expr_t>
        -_sortedFiles : std::vector<File*>
        -_filteredFiles : std::vector<File*>
        -_sortFiltFiles : std::vector<File*>
        -_storingConn : IConnection*
        -_storingPath : std::string
        +FNIFI(colls : std::vector<Collection*>&, storingConn : IConnection*,
        storingPath : const char*)
        +index()
        +defragment()
        +sort(exp : const char*)
        +filter(exp : const char*)
        +getFiles() : const std::vector<File*>&
        +begin() : const_iterator
        +end() : const_iterator
    }

    package file {
        enum MetadataType {
            +XMP
            +EXIF
            +IPTC
        }

        interface IFileHelper {
            +getFilePath(id : fileId_t) : std::string
            +getStats(id : fileId_t) : struct stat
            +preview(id : fileId_t) : fileBuf_t
            +read(id : fileId_t) : fileBuf_t
        }

        class File {
            -_id : const fileId_t
            -_helper : const IFileHelper*
            +File(id : fileId_t, helper : const IFileHelper*)
            +operator==(other : const File&) : bool
            +getId() : fileId_t
            +getPath() : std::string
            +getStats() : struct stat
            +getMetadata(os : std::ostream&, type : MetadataType,
            key : const char*) : std::ostream&
            +preview() : fileBuf_t
            +read() : fileBuf_t
        }

        class Collection extends IFileHelper {
            -_indexingConn : IConnection*
            -_storingConn : IConnection*
            -_tmpPath : const char*
            -_files : std::unordered_set<File>
            -_mapping : std::fstream
            -_filepaths : std::fstream
            -_availableIds : std::unordered_set<filedId_t>
            +Collection(indexingConn : IConnection*,
            storingConn : IConnection*, tmpPath : const char*,
            storingPath : const char*)
            +~Collection()
            +index(removed : std::unordered_set<fileId_t>&,
            added : std::unordered_set<fileId_t>&, modified : std::unordered_set<fileId_t>&)
            +defragment()
            +getFilePath(id : fileId_t) : std::string
            +getStats(id : fileId_t) : struct stat
            +preview(id : fileId_t) : fileBuf_t
            +read(id : fileId_t) : fileBuf_t
            +begin() : std::unordered_set<File>::const_iterator
            +end() : std::unordered_set<File>::const_iterator
            +size() : size_t
            -getPreviewFilePath(id : fileId_t) : std::string
            -pullStored()
            -pushStored()
        }
    }

    package connection {
        struct DirectoryIterator::Entry {
            +path : std::string
            +ctime : struct timespec
            +operator==(other : const Entry&)
        }

        class DirectoryIterator {
            -_entries : std::vector<Entry, EntryHash>
            +DirectoryIterator(its : std::filesystem::recursive_directory_iterator,
            bool files, bool folders)
            +DirectoryIterator(its : std::filesystem::directory_iterator,
            bool files, bool folders)
            +DirectoryIterator(data : void*, nextEntry : std::function<...>&)
            +DirectoryIterator(dirit : const DirectoryEntry&, path : const char*)
            +begin() : std::vector<Entry, EntryHash>::const_iterator
            +end() : std::vector<Entry, EntryHash>::const_iterator
            +size() : size_t
            -{static} get_auth_data_with_context_fn(...)
            -{static} nextEntry(data : void*, absname : std::string&) : const libsmb_file_info*
        }

        interface IConnection {
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : const char*, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : const char*) : bool
            +getStats(filepath : const char*) : struct stat
            +read(filepath : const char*) : fileBuf_t
            +write(filepath : const char*, buffer : const fileBuf_t&)
            +download(from : const char*, to : const char*)
            +upload(from : const char*, to : const char*)
            +remove(filepath : const char*)
        }

        class Relative extends IConnection {
            -_conn : const IConnection*
            -_path : std::string
            +Relative(conn : IConnection*, path : const char*)
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : const char*, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : const char*) : bool
            +getStats(filepath : const char*) : struct stat
            +read(filepath : const char*) : fileBuf_t
            +write(filepath : const char*, buffer : const fileBuf_t&)
            +download(from : const char*, to : const char*)
            +upload(from : const char*, to : const char*)
            +remove(filepath : const char*)
        }

        class SMB extends IConnection {
            -_userdata : struct UserData
            -_ctx : SMBCCTX*
            -_path : std::string
            +SMB(addr : const char*, user : const char*, pwd : const char*)
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : const char*, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : const char*) : bool
            +getStats(filepath : const char*) : struct stat
            +read(filepath : const char*) : fileBuf_t
            +write(filepath : const char*, buffer : const fileBuf_t&)
            +download(from : const char*, to : const char*)
            +upload(from : const char*, to : const char*)
            +remove(filepath : const char*)
        }

        class Local extends IConnection {
            +Local()
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : const char*, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : const char*) : bool
            +getStats(filepath : const char*) : struct stat
            +read(filepath : const char*) : fileBuf_t
            +write(filepath : const char*, buffer : const fileBuf_t&)
            +download(from : const char*, to : const char*)
            +upload(from : const char*, to : const char*)
            +remove(filepath : const char*)
        }
    }

    FNIFI o--> Collection : 0..*\n_colls
    FNIFI o--> File : 0..*\n_sortedFiles
    FNIFI o--> File : 0..*\n_filteredFiles
    FNIFI o--> File : 0..*\n_sortFiltFiles
    FNIFI o--> IConnection : 1..1\n_storingConn
    File o--> IFileHelper : 1..1\n_coll
    Collection o--> IConnection : 1..1\n_indexingConn
    Collection o--> IConnection : 1..1\n_storingConn
    Collection *--> File : 0..*\n_files
    Relative o--> IConnection : 1..1\n_conn
    DirectoryIterator *--> DirectoryIterator::Entry : 0..*\n_entries
}

@enduml
