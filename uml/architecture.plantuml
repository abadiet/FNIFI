@startuml

package userspace {
    class Main {
    }
}

package fnifi {
    class FNIFI {
        -_colls : const std::vector<Collection*>
        -_sortExpr : std::unique_ptr<expression::Expression>
        -_filtExpr : std::unique_ptr<expression::Expression>
        -_files : fileset_t
        -_toRemove : std::unordered_set<const file::File*>&
        -_storingConn : IConnection*
        -_storingPath : const std::filesystem::path
        +FNIFI(colls : std::vector<Collection*>&, storingConn : IConnection*,
        storingPath : const std::filesystem::path&)
        +index()
        +defragment()
        +sort(exp : const std::string&)
        +filter(exp : const std::string&)
        +getFiles() : const std::vector<File*>&
        +begin() : Iterator
        +end() : Iterator
    }

    class FNIFI::Iterator {
        -_p : fileset_t::const_iterator
        -_toRemove : std::unordered_set<const file::File*>&
        -_files : fileset_t&
        +Iterator(...)
        +operator*() : reference
        +operator->() : pointer
        +operator++() : Iterator&
        +operator++(int) : Iterator
        +operator==(other : const Iterator&) : bool
        +operator!=(other : const Iterator&) : bool
    }

    package expression {
        abstract DiskBacked {
            -_storedColls : std::unordered_map<std::string, StoredColl>
            -getValue(file : const file::File*, noCache : bool) : expr_t
            +{static} Uncache(storingPath : const std::string&,
            collName : const std::string&, id : fileId_t)
            +DiskBacked(key : const std::string&, storingPath : const std::filesystem::path&,
            colls : std::vector<file::Collection*>&, parentDirName : const std::string&)
            +~DiskBacked()
            +get(file : const file::File*, noCache : bool := false) : expr_t
            +update()
        }

        class Expression extends DiskBacked {
            -_handler : std::function<expr_t&(const std::string&>
            -_sxeval : sxeval::SXEval<expr_t>
            -_vars : std::vector<struct RefVar>
            -getValue(file : const file::File*, noCache : bool) : expr_t
            +Expression(expr : const std::string&, storingPath : const std::filesystem::path&,
            colls : const std::vector<file::Collection*>&)
        }

        class Variable extends DiskBacked {
            -_type : Type
            -_key : std::string
            -getValue(file : const file::File*, noCache : bool) : expr_t
            +{static} GetType(name : const std::string&) : Type
            +Variable(key : const std::string&, storingPath : const std::filesystem::path&,
            colls : const std::vector<file::Collection*>&)
        }

        enum Variable::Type {
            +CTIME
            +UNKNOWN
        }

    }

    package file {
        enum MetadataType {
            +XMP
            +EXIF
            +IPTC
        }

        interface IFileHelper {
            +getFilePath(id : fileId_t) : std::string
            +getStats(id : fileId_t) : struct stat
            +preview(id : fileId_t) : fileBuf_t
            +read(id : fileId_t) : fileBuf_t
            +getName() : std::string
        }

        class File {
            -_id : const fileId_t
            -_sortScore : expr_t
            -_isFilteredOut : bool
            -_helper : const IFileHelper*
            +File(id : fileId_t, helper : const IFileHelper*)
            +operator==(other : const File&) : bool
            +getId() : fileId_t
            +getPath() : std::string
            +getStats() : struct stat
            +getMetadata(os : std::ostream&, type : MetadataType,
            key : const std::string&) : std::ostream&
            +preview() : fileBuf_t
            +read() : fileBuf_t
            +setSortingScore(score : expr_t)
            +setIsFilteredOut(isFilteredOut : bool)
            +isFileteredOut() : boll
            +getCollectionName() : std::string
        }

        class Collection extends IFileHelper {
            -_indexingConn : IConnection*
            -_storingConn : IConnection*
            -_tmpPath : std::filesystem::path
            -_files : std::unordered_map<fileId_t, File>
            -_mapping : std::fstream
            -_filepaths : std::fstream
            -_availableIds : std::unordered_set<filedId_t>
            +Collection(indexingConn : IConnection*, storingConn : IConnection*,
            tmpPath : const std::filesystem::path&)
            +~Collection()
            +index(removed : std::unordered_set<std::pair<const file::File*, fileId_t>&,
            added : std::unordered_set<const file::File*>&,
            modified : std::unordered_set<const file::File*>&)
            +defragment()
            +getFilePath(id : fileId_t) : std::string
            +getStats(id : fileId_t) : struct stat
            +preview(id : fileId_t) : fileBuf_t
            +read(id : fileId_t) : fileBuf_t
            +getName() : std::string
            +begin() : std::unordered_map<fileId_t, File>::const_iterator
            +end() : std::unordered_map<fileId_t, File>::const_iterator
            +begin() : std::unordered_map<fileId_t, File>::iterator
            +end() : std::unordered_map<fileId_t, File>::iterator
            +size() : size_t
            -getPreviewFilePath(id : fileId_t) : std::string
            -pullStored()
            -pushStored()
        }
    }

    package connection {
        struct DirectoryIterator::Entry {
            +path : std::string
            +ctime : struct timespec
            +operator==(other : const Entry&)
        }

        class DirectoryIterator {
            -_entries : std::vector<Entry, EntryHash>
            +DirectoryIterator(its : std::filesystem::recursive_directory_iterator,
            bool files, bool folders)
            +DirectoryIterator(its : std::filesystem::directory_iterator,
            bool files, bool folders)
            +DirectoryIterator(data : void*, nextEntry : std::function<...>&)
            +DirectoryIterator(dirit : const DirectoryEntry&,
            path : const std::filesystem::path&)
            +begin() : std::vector<Entry, EntryHash>::const_iterator
            +end() : std::vector<Entry, EntryHash>::const_iterator
            +size() : size_t
            -{static} get_auth_data_with_context_fn(...)
            -{static} nextEntry(data : void*, absname : std::string&) : const libsmb_file_info*
        }

        interface IConnection {
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : std::filesystem::path&, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : std::filesystem::path&) : bool
            +getStats(filepath : std::filesystem::path&) : struct stat
            +read(filepath : std::filesystem::path&) : fileBuf_t
            +write(filepath : std::filesystem::path&, buffer : const fileBuf_t&)
            +download(from : std::filesystem::path&, to : std::filesystem::path&)
            +upload(from : std::filesystem::path&, to : std::filesystem::path&)
            +remove(filepath : std::filesystem::path&)
            +getName() : std::string
        }

        class Relative extends IConnection {
            -_conn : const IConnection*
            -_path : std::string
            +Relative(conn : IConnection*, path : std::filesystem::path&)
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : std::filesystem::path&, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : std::filesystem::path&) : bool
            +getStats(filepath : std::filesystem::path&) : struct stat
            +read(filepath : std::filesystem::path&) : fileBuf_t
            +write(filepath : std::filesystem::path&, buffer : const fileBuf_t&)
            +download(from : std::filesystem::path&, to : std::filesystem::path&)
            +upload(from : std::filesystem::path&, to : std::filesystem::path&)
            +remove(filepath : std::filesystem::path&)
            +getName() : std::string
        }

        class SMB extends IConnection {
            -_userdata : struct UserData
            -_ctx : SMBCCTX*
            -_path : std::string
            +SMB(addr : const std::string&, user : const std::string&,
            pwd : const std::string&)
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : std::filesystem::path&, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : std::filesystem::path&) : bool
            +getStats(filepath : std::filesystem::path&) : struct stat
            +read(filepath : std::filesystem::path&) : fileBuf_t
            +write(filepath : std::filesystem::path&, buffer : const fileBuf_t&)
            +download(from : std::filesystem::path&, to : std::filesystem::path&)
            +upload(from : std::filesystem::path&, to : std::filesystem::path&)
            +remove(filepath : std::filesystem::path&)
            +getName() : std::string
        }

        class Local extends IConnection {
            +Local()
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : std::filesystem::path&, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : std::filesystem::path&) : bool
            +getStats(filepath : std::filesystem::path&) : struct stat
            +read(filepath : std::filesystem::path&) : fileBuf_t
            +write(filepath : std::filesystem::path&, buffer : const fileBuf_t&)
            +download(from : std::filesystem::path&, to : std::filesystem::path&)
            +upload(from : std::filesystem::path&, to : std::filesystem::path&)
            +remove(filepath : std::filesystem::path&)
            +getName() : std::string
        }
    }
}

Main *--> FNIFI
note on link
<u>FNIFI</u> instances are owns by the user program.
They enable them to sort and filter the files.
end note
Main *--> Collection
note on link
<u>Collection</u> instances are owns by the user program.
Provided to <u>FNIFI</u> instances (see <u>colls</u> in <u>FNIFI</u>'s
constructor), they enable them to iterate over the files.
end note
Main *--> IConnection
note on link
<u>IConnection</u> instances are owns by the user program.
Provided to both <u>FNIFI</u> anf <u>Collection</u> instances, they enable them
to interact with the files.
end note
FNIFI o--> Collection : 0..*\n_colls
FNIFI o--> IConnection : 1..1\n_storingConn
FNIFI *--> Expression : 1..1\n_storExpr
FNIFI *--> Expression : 1..1\n_filtExpr
FNIFI o--> File : 0..*\n_files
FNIFI o--> File : 0..*\n_toRemove
File o--> IFileHelper : 1..1\n_coll
Collection o--> IConnection : 1..1\n_indexingConn
Collection o--> IConnection : 1..1\n_storingConn
Collection *--> File : 0..*\n_files
Relative o--> IConnection : 1..1\n_conn
DirectoryIterator *--> DirectoryIterator::Entry : 0..*\n_entries
Expression *--> Variable : 0..*\n_vars
Variable *--> Variable::Type : 1..1\n_type

@enduml
