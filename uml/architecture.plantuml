@startuml

package fnifi {
    class FNIFI {
        -_colls : std::vector<Collection*>
        -_sortExpr : expression::Expression
        -_filtExpr : expression::Expression
        -_files : fileset_t
        -_toRemove : std::unordered_set<const file::File*>&
        -_storingConn : IConnection*
        -_storingPath : std::string
        +FNIFI(colls : std::vector<Collection*>&, storingConn : IConnection*,
        storingPath : const char*)
        +index()
        +defragment()
        +sort(exp : const char*)
        +filter(exp : const char*)
        +getFiles() : const std::vector<File*>&
        +begin() : Iterator
        +end() : Iterator
    }

    class FNIFI::Iterator {
        -_p : fileset_t::const_iterator
        -_toRemove : std::unordered_set<const file::File*>&
        -_files : fileset_t&
        +Iterator(...)
        +operator*() : reference
        +operator->() : pointer
        +operator++() : Iterator&
        +operator++(int) : Iterator
        +operator==(other : const Iterator&) : bool
        +operator!=(other : const Iterator&) : bool
    }

    package expression {
        class Expression {
            -_stored : std::fstream
            -_storingPath = std::string
            -_handler : std::function<expr_t&(const std::string&>
            -_sxeval : sxeval::SXEval<expr_t>
            -_vars : std::vector<struct RefVar>
            -_maxId : fileId_t
            -getValue(file : const file::File*) : expr_t
            -{static} GetHash(s : const std::string&);
            +Expression()
            +build(expr : const std::string&, storingPath : const std::string&)
            +run(file : const file::File*, noCache : bool := false)
            +remove(id : fileId_t)
        }

        class Variable {
            -_stored : std::fstream
            -_maxId : fileId_t
            -_type : const Type
            -_key : const std::string
            -{static} _built : std::unordered_map<std::string, Variable>
            -getValue(file : const file::File*) : expr_t
            +{static} Build(type : Type, key : const std::string&, storingPath : const char*)
            +{static} GetType(name : const std::string&) : Type
            +~Variable()
            +get(file : const file::File*) : expr_t
            +Variable(type : Type, key : const std::string&, storingPath : const char*)
        }

        enum Variable::Type {
            +CTIME
            +UNKNOWN
        }

    }

    package file {
        enum MetadataType {
            +XMP
            +EXIF
            +IPTC
        }

        interface IFileHelper {
            +getFilePath(id : fileId_t) : std::string
            +getStats(id : fileId_t) : struct stat
            +preview(id : fileId_t) : fileBuf_t
            +read(id : fileId_t) : fileBuf_t
        }

        class File {
            -_id : const fileId_t
            -_sort : expr_t
            -_isFilteredOut : bool
            -_helper : const IFileHelper*
            +File(id : fileId_t, helper : const IFileHelper*)
            +operator==(other : const File&) : bool
            +getId() : fileId_t
            +getPath() : std::string
            +getStats() : struct stat
            +getMetadata(os : std::ostream&, type : MetadataType,
            key : const char*) : std::ostream&
            +preview() : fileBuf_t
            +read() : fileBuf_t
            +setSortingScore(score : expr_t)
            +setIsFilteredOut(isFilteredOut : bool)
            +isFileteredOut() : boll
        }

        class Collection extends IFileHelper {
            -_indexingConn : IConnection*
            -_storingConn : IConnection*
            -_tmpPath : std::filesystem::path
            -_files : std::unordered_map<fileId_t, File>
            -_mapping : std::fstream
            -_filepaths : std::fstream
            -_availableIds : std::unordered_set<filedId_t>
            +Collection(indexingConn : IConnection*, storingConn : IConnection*,
            tmpPath : const char*)
            +~Collection()
            +index(removed : std::unordered_set<std::pair<const file::File*, fileId_t>&,
            added : std::unordered_set<const file::File*>&,
            modified : std::unordered_set<const file::File*>&)
            +defragment()
            +getFilePath(id : fileId_t) : std::string
            +getStats(id : fileId_t) : struct stat
            +preview(id : fileId_t) : fileBuf_t
            +read(id : fileId_t) : fileBuf_t
            +begin() : std::unordered_map<fileId_t, File>::const_iterator
            +end() : std::unordered_map<fileId_t, File>::const_iterator
            +begin() : std::unordered_map<fileId_t, File>::iterator
            +end() : std::unordered_map<fileId_t, File>::iterator
            +size() : size_t
            -getPreviewFilePath(id : fileId_t) : std::string
            -pullStored()
            -pushStored()
        }
    }

    package connection {
        struct DirectoryIterator::Entry {
            +path : std::string
            +ctime : struct timespec
            +operator==(other : const Entry&)
        }

        class DirectoryIterator {
            -_entries : std::vector<Entry, EntryHash>
            +DirectoryIterator(its : std::filesystem::recursive_directory_iterator,
            bool files, bool folders)
            +DirectoryIterator(its : std::filesystem::directory_iterator,
            bool files, bool folders)
            +DirectoryIterator(data : void*, nextEntry : std::function<...>&)
            +DirectoryIterator(dirit : const DirectoryEntry&, path : const char*)
            +begin() : std::vector<Entry, EntryHash>::const_iterator
            +end() : std::vector<Entry, EntryHash>::const_iterator
            +size() : size_t
            -{static} get_auth_data_with_context_fn(...)
            -{static} nextEntry(data : void*, absname : std::string&) : const libsmb_file_info*
        }

        interface IConnection {
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : const char*, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : const char*) : bool
            +getStats(filepath : const char*) : struct stat
            +read(filepath : const char*) : fileBuf_t
            +write(filepath : const char*, buffer : const fileBuf_t&)
            +download(from : const char*, to : const char*)
            +upload(from : const char*, to : const char*)
            +remove(filepath : const char*)
        }

        class Relative extends IConnection {
            -_conn : const IConnection*
            -_path : std::string
            +Relative(conn : IConnection*, path : const char*)
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : const char*, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : const char*) : bool
            +getStats(filepath : const char*) : struct stat
            +read(filepath : const char*) : fileBuf_t
            +write(filepath : const char*, buffer : const fileBuf_t&)
            +download(from : const char*, to : const char*)
            +upload(from : const char*, to : const char*)
            +remove(filepath : const char*)
        }

        class SMB extends IConnection {
            -_userdata : struct UserData
            -_ctx : SMBCCTX*
            -_path : std::string
            +SMB(addr : const char*, user : const char*, pwd : const char*)
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : const char*, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : const char*) : bool
            +getStats(filepath : const char*) : struct stat
            +read(filepath : const char*) : fileBuf_t
            +write(filepath : const char*, buffer : const fileBuf_t&)
            +download(from : const char*, to : const char*)
            +upload(from : const char*, to : const char*)
            +remove(filepath : const char*)
        }

        class Local extends IConnection {
            +Local()
            +connect()
            +disconnect(aggressive : bool := false)
            +iterate(path : const char*, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : const char*) : bool
            +getStats(filepath : const char*) : struct stat
            +read(filepath : const char*) : fileBuf_t
            +write(filepath : const char*, buffer : const fileBuf_t&)
            +download(from : const char*, to : const char*)
            +upload(from : const char*, to : const char*)
            +remove(filepath : const char*)
        }
    }

    FNIFI o--> Collection : 0..*\n_colls
    FNIFI o--> IConnection : 1..1\n_storingConn
    FNIFI *--> Expression : 1..1\n_storExpr
    FNIFI *--> Expression : 1..1\n_filtExpr
    FNIFI o--> File : 0..*\n_files
    FNIFI o--> File : 0..*\n_toRemove
    File o--> IFileHelper : 1..1\n_coll
    Collection o--> IConnection : 1..1\n_indexingConn
    Collection o--> IConnection : 1..1\n_storingConn
    Collection *--> File : 0..*\n_files
    Relative o--> IConnection : 1..1\n_conn
    DirectoryIterator *--> DirectoryIterator::Entry : 0..*\n_entries
    Expression *--> Variable : 0..*\n_vars
    Variable *--> Variable::Type : 1..1\n_type
}

@enduml
