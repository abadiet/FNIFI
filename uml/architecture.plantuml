@startuml

package userspace {
    class Main {
    }
}

package fnifi {
    class FNIFI {
        -_colls : const std::vector<file::Collection*>
        -_sortExpr : std::unique_ptr<expression::Expression>
        -_filtExpr : std::unique_ptr<expression::Expression>
        -_files : fileset_t
        -_toRemove : std::unordered_set<const file::File*>&
        -_storing : const utils::SyncDirectory&
        -indexColl(coll : file::Collection&)
        -sortColl(coll : file::Collection&)
        -filterColl(coll : file::Collection&)
        +FNIFI(storing : const utils::SyncDirectory&)
        +addCollection(colls : std::vector<file::Collection*>&, index : bool := false)
        +index()
        +defragment()
        +sort(exp : const std::string&)
        +filter(exp : const std::string&)
        +getFiles() : const std::vector<File*>&
        +begin() : Iterator
        +end() : Iterator
        +getFiles() : fileset_t
    }

    class FNIFI::Iterator {
        -_p : fileset_t::const_iterator
        -_toRemove : std::unordered_set<const file::File*>&
        -_files : fileset_t&
        +Iterator(...)
        +operator*() : reference
        +operator->() : pointer
        +operator++() : Iterator&
        +operator++(int) : Iterator
        +operator==(other : const Iterator&) : bool
        +operator!=(other : const Iterator&) : bool
    }

    package utils {
        class TempFile <<std::fstream>> {
            -{static} _charset : const char[63]
            -_path : const std::filesystem::path
            +TempFile()
            +~TempFile()
            +getPath() : std::filesystem::path
            -{static} RandomChar() : char
            -{static} RandomString(size : unsigned char) : std::string
            -{static} RandomFilepath(size : unsigned char) : std::filesystem::path
        }

        class SyncDirector::FileStream <<std::fstreamd>> {
            -_sync : const SyncDirectory&
            -_abspath : const std::filesystem::path&
            -_relapath : const std::filesystem::path&
            -_syncDisabled : bool
            -setup(ate : bool)
            -FileStream(abspath : const std::filesystem::path&,
            relapath : const std::filesystem::path&, ate : bool, sync : const SyncDirectory&)
            +FileStream(sync : const SyncDirectory&, filepath : const std::filesystem::path&,
            ate : bool := false)
            +pull()
            +push()
            +disableSync(pull : bool := true)
            +enableSync(push : bool := true)
            +take(file : TempFile&)
            +getPath(relative : bool := false) : std::filesystem::path
        }

        class SyncDirectory {
            -_conn : const IConnection*
            -_path : const std::filesystem::path
            -setupFileStream(filepath : const std::filesystem::path&,
            mkdir : bool := true) : std::filesystemm::path
            -pull(abspath : const std::filesystem::path&,
            relapath : const std::filesystem::path&) : bool
            -push(relapath : const std::filesystem::path&, buf : const fileBuf_t&)
            +SyncDirectory(conn : const IConnection*, path : const std::string&)
            +open(filepath : const std::filesystem::path&, ate : bool := false,
            mkdir : bool := true) : FileStream
            +exists(filepath : const std::filesystem::path&) : bool
            +absolute(filepath : const std::filesystem::path&) : std::filesystem::path
            +remove(filepath : const std::filesystem::path&)
            +createDirs(dirpath : const std::filesystem::path&)
        }
    }

    package expression {
        abstract DiskBacked {
            -_storedColls : std::unordered_map<std::string, StoredColl>
            -_keyHash : const std::string
            -_storing : const utils::SyncDirectory&
            -_parentDirName : const std::filesystem::path&
            -getValue(file : const file::File*, noCache : bool) : expr_t
            +{static} Uncache(storing : const utils::SyncDirectory&,
            path : const std::filesystem::path&, id : fileId_t)
            +DiskBacked(key : const std::string&, storing : const conection::SyncDirectory&,
            colls : std::vector<file::Collection*>&, parentDirName : const std::string&)
            +~DiskBacked()
            +get(file : const file::File*, noCache : bool := false) : expr_t
            +addCollection(coll : const file::Collection&)
            +disableSync(collName : const std::filesystem::path&, pull : bool := true)
            +enableSync(collName : const std::filesystem::path&, push : bool := true)
        }

        class Expression extends DiskBacked {
            -_handler : std::function<expr_t&(const std::string&>
            -_sxeval : sxeval::SXEval<expr_t>
            -_vars : std::vector<struct RefVar>
            -getValue(file : const file::File*, noCache : bool) : expr_t
            +{static} Uncache(storing : const utils::SyncDirectory&,
            +Expression(expr : const std::string&, storing : const utils::SyncDirectory&,
            colls : const std::vector<file::Collection*>&)
            +addCollection(coll : const file::Collection&)
            +disableSync(collName : const std::filesystem::path&, pull : bool := true)
            +enableSync(collName : const std::filesystem::path&, push : bool := true)
        }

        class Variable extends DiskBacked {
            -_type : Kind
            -_key : std::string
            -getValue(file : const file::File*, noCache : bool) : expr_t
            +{static} GetKind(name : const std::string&) : Kind
            +{static} Uncache(storing : const utils::SyncDirectory&,
            +Variable(key : const std::string&, storing : const utils::SyncDirectory&,
            colls : const std::vector<file::Collection*>&)
            +disableSync(collName : const std::filesystem::path&, pull : bool := true)
            +enableSync(collName : const std::filesystem::path&, push : bool := true)
        }

        enum Kind {
            +CTIME
            +XMP
            +EXIF
            +IPTC
            +UNKNOWN
        }

        Variable *--> Kind : 1..1\n_type

    }

    package file {
        enum Kind {
            +BMP
            +GIF
            +JPEG2000
            +JPEG
            +PNG
            +WEBP
            +AVIF
            +PBM
            +PGM
            +PPM
            +PXM
            +PFM
            +SR
            +RAS
            +TIFF
            +EXR
            +HDR
            +PIC
            +UNKNOWN
        }

        interface IFileHelper {
            +getFilePath(id : fileId_t) : std::string
            +getLocalPreviewFilePath(id : fileId_t) : std::string
            +getLocalCopyFilePath(id : fileId_t) : std::string
            +getStats(id : fileId_t) : struct stat
            +getKind(id : fileId_t) : Kind
            +read(id : fileId_t) : fileBuf_t
            +getName() : std::string
        }

        class File {
            -_id : const fileId_t
            -_sortScore : expr_t
            -_isFilteredOut : bool
            -_helper : const IFileHelper*
            +File(id : fileId_t, helper : const IFileHelper*)
            +operator==(other : const File&) : bool
            +getId() : fileId_t
            +getPath() : std::string
            +getLocalPreviewPath() : std::string
            +getLocalCopyFilePath() : std::string
            +getStats() : struct stat
            +getKind() : Kind
            +getMetadata(os : std::ostream&, type : expression::Kind,
            key : const std::string&) : std::ostream&
            +read() : fileBuf_t
            +setSortingScore(score : expr_t)
            +setIsFilteredOut(isFilteredOut : bool)
            +isFileteredOut() : boll
            +getCollectionName() : std::string
            +setHelper(IFileHelper* helper)
        }

        class Collection extends IFileHelper {
            -_indexingConn : IConnection*
            -_storing : const utils::SyncDirectory&
            -_storingPath : const std::filesystem::path
            -_files : std::unordered_map<fileId_t, File>
            -_mapping : std::unique_ptr<utils::SyncDirectory::FileStream>
            -_filepaths : std::unique_ptr<utils::SyncDirectory::FileStream>
            -_info : std::unique_ptr<utils::SyncDirectory::FileStream>
            -_availableIds : std::unordered_set<filedId_t>
            -_maxCopiesSz: const size_t
            -_copiesSz: size_t
            -{static} GetKind(buf : const fileBuf_t&) : Kind
            -{static} StartWith(buf : const fileBuf_t&, chars: const char*, n: size_t
            offset: difference_type := 0) : bool
            -removePreviewFile(id : fileId_t)
            -removeCopyFile(id : fileId_t)
            -updateCopiesSz()
            +Collection(indexingConn : IConnection*, storing : const utils::SyncDirectory&,
            maxCopiesSz : size_t := 1024000000L)
            +Collection(other : Collection&&)
            +~Collection()
            +index(removed : std::unordered_set<std::pair<const file::File*, fileId_t>&,
            added : std::unordered_set<const file::File*>&,
            modified : std::unordered_set<const file::File*>&)
            +defragment()
            +getFilePath(id : fileId_t) : std::string
            +getLocalPreviewFilePath(id : fileId_t) : std::string
            +getLocalCopyFilePath(id : fileId_t) : std::string
            +getStats(id : fileId_t) : struct stat
            +getKind(id : fileId_t) : Kind
            +read(id : fileId_t) : fileBuf_t
            +getName() : std::string
            +begin() : std::unordered_map<fileId_t, File>::const_iterator
            +end() : std::unordered_map<fileId_t, File>::const_iterator
            +begin() : std::unordered_map<fileId_t, File>::iterator
            +end() : std::unordered_map<fileId_t, File>::iterator
            +size() : size_t
            -removePreviewFile(fileId_t id)
        }
    }

    package connection {
        struct ConnectionBuilder::Options {
            +relativePath : std::string
        }

        class ConnectionBuilder {
            -{static} _built : std::unordered_map<std::string, IConnection*>
            +{static} GetLocal(opt : const Options&) : IConnection*
            +{static} GetSMB(addr : const std::string&, user : const std::string&,
            pwd : const std::string&, opt : const Options&) : IConnection*
            +{static} Free()
        }

        struct DirectoryIterator::Entry {
            +path : std::string
            +ctime : struct timespec
            +operator==(other : const Entry&)
        }

        class DirectoryIterator {
            -_entries : std::vector<Entry, EntryHash>
            -addEntry(entry : const std::filesystem::path&, files : boll, folders : bool)
            +DirectoryIterator(its : std::filesystem::recursive_directory_iterator,
            bool files, bool folders)
            +DirectoryIterator(its : std::filesystem::directory_iterator,
            bool files, bool folders)
            +DirectoryIterator(data : void*, nextEntry : std::function<...>&)
            +DirectoryIterator(dirit : const DirectoryEntry&,
            path : const std::filesystem::path&)
            +begin() : std::vector<Entry, EntryHash>::const_iterator
            +end() : std::vector<Entry, EntryHash>::const_iterator
            +size() : size_t
        }

        interface IConnection {
            +connect()
            +disconnect(force : bool := false)
            +iterate(path : std::filesystem::path&, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : std::filesystem::path&) : bool
            +getStats(filepath : std::filesystem::path&) : struct stat
            +read(filepath : std::filesystem::path&) : fileBuf_t
            +write(filepath : std::filesystem::path&, buffer : const fileBuf_t&)
            +download(from : std::filesystem::path&, to : std::filesystem::path&) : bool
            +upload(from : std::filesystem::path&, to : std::filesystem::path&) : bool
            +remove(filepath : std::filesystem::path&)
            +createDirs(path : const std::filesystem::path&)
            +getName() : std::string
        }

        class Relative extends IConnection {
            -_conn : const IConnection*
            -_path : std::string
            +Relative(conn : IConnection*, path : std::filesystem::path&)
            +connect()
            +disconnect(force : bool := false)
            +iterate(path : std::filesystem::path&, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : std::filesystem::path&) : bool
            +getStats(filepath : std::filesystem::path&) : struct stat
            +read(filepath : std::filesystem::path&) : fileBuf_t
            +write(filepath : std::filesystem::path&, buffer : const fileBuf_t&)
            +download(from : std::filesystem::path&, to : std::filesystem::path&) : bool
            +upload(from : std::filesystem::path&, to : std::filesystem::path&) : bool
            +remove(filepath : std::filesystem::path&)
            +createDirs(path : const std::filesystem::path&)
            +getName() : std::string
        }

        class SMB extends IConnection {
            -...
            +SMB(server : const std::string&, share : const std::string&,
            username : const std::string&, password : const std::string&)
            +connect()
            +disconnect(force : bool := false)
            +iterate(path : std::filesystem::path&, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : std::filesystem::path&) : bool
            +getStats(filepath : std::filesystem::path&) : struct stat
            +read(filepath : std::filesystem::path&) : fileBuf_t
            +write(filepath : std::filesystem::path&, buffer : const fileBuf_t&)
            +download(from : std::filesystem::path&, to : std::filesystem::path&) : bool
            +upload(from : std::filesystem::path&, to : std::filesystem::path&) : bool
            +remove(filepath : std::filesystem::path&)
            +createDirs(path : const std::filesystem::path&)
            +getName() : std::string
        }

        class Local extends IConnection {
            +Local()
            +connect()
            +disconnect(force : bool := false)
            +iterate(path : std::filesystem::path&, recursive : bool := true,
            files : bool := true, folders := false) : DirectoryIterator
            +exists(filepath : std::filesystem::path&) : bool
            +getStats(filepath : std::filesystem::path&) : struct stat
            +read(filepath : std::filesystem::path&) : fileBuf_t
            +write(filepath : std::filesystem::path&, buffer : const fileBuf_t&)
            +download(from : std::filesystem::path&, to : std::filesystem::path&) : bool
            +upload(from : std::filesystem::path&, to : std::filesystem::path&) : bool
            +remove(filepath : std::filesystem::path&)
            +createDirs(path : const std::filesystem::path&)
            +getName() : std::string
        }
    }
}

Main *--> FNIFI
note on link
<u>FNIFI</u> instances are owns by the user program.
They enable them to sort and filter the files.
end note

Main *--> Collection
note on link
<u>Collection</u> instances are owns by the user program.
Provided to <u>FNIFI</u> instances (see <u>colls</u> in <u>FNIFI</u>'s
constructor), they enable them to iterate over the files.
end note

Main *--> IConnection
note on link
<u>IConnection</u> instances are owns by the user program.
Provided to <u>Collection</u> instances (see <u>indexingConn</u> and
<u>storingConn</u>), they enable them to interact with the files.
end note

Main *--> SyncDirectory
note on link
<u>SyncDirectory</u> instances are owns by the user program.
Provided to both <u>Collection</u> and <u>FNIFI</u> instances (see <u>storingConn</u>),
they enable them to synchronize files between a remote location (a <u>IConnection</u>)
and the local file system. The point is to make process locally to then save it remotely.
end note

FNIFI o--> Collection : 0..*\n_colls
FNIFI *--> Expression : 1..1\n_storExpr
FNIFI *--> Expression : 1..1\n_filtExpr
FNIFI o--> File : 0..*\n_files
FNIFI o--> File : 0..*\n_toRemove
FNIFI o--> SyncDirectory : 1..1\n_storing
File o--> IFileHelper : 1..1\n_coll
Collection o--> IConnection : 1..1\n_indexingConn
Collection o--> SyncDirectory : 1..1\n_storing
Collection *--> File : 0..*\n_files
Collection *--> SyncDirectory::FileStream : 0..*\n_mapping
Collection *--> SyncDirectory::FileStream : 0..*\n_filepaths
Relative o--> IConnection : 1..1\n_conn
DirectoryIterator *--> DirectoryIterator::Entry : 0..*\n_entries
Expression *--> Variable : 0..*\n_vars
DiskBacked *--> SyncDirectory::FileStream : 0..*\n_storedColls
DiskBacked *--> SyncDirectory : 1..1\n_storing

@enduml
